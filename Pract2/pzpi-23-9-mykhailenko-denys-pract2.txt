Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії




Звіт
до практичного завдання №2
з дисципліни «Аналіз та рефакторинг коду»
на тему: «Методи рефакторингу коду програмного забезпечення: Hide Delegate, Pull Up Method, Replace Parameter with Explicit Methods»






Виконав:
ст. гр. ПЗПІ-23-9
Михайленко Денис Олегович   
	         Перевірив:
         ст. викладач кафедри ПІ
         Сокорчук Ігор Петрович








Харків 2025
1 ІСТОРІЯ ЗМІН
№	Дата	Версія звіту	Опис змін та виправлень
1	27.11.2025	0.1	Початкова версія документу
2	28.11.2025	1	Остаточна версія документ

 
2 ЗАВДАННЯ
1. Студент повинен обрати три методи рефакторингу коду із книги Мартіна Фаулера «Refactoring. Improving the Design of Existing Code».
2. Навести приклади свого особистого коду (з курсових, лабораторних або інших проєктів), який потребує покращення, та продемонструвати застосування обраних методів. 
3. Кожен метод рефакторингу повинен супроводжуватись:
•	Описом проблеми, яку вирішує даний метод.
•	Кодом до і після застосування методу рефакторингу.
•	Поясненням переваг використаного методу.
 
3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Вступ
Рефакторинг коду є важливою практикою у розробці програмного забезпечення, адже він дозволяє покращити структуру програми без зміни її зовнішньої поведінки. Метою цього практичного заняття є вміння ідентифікувати недоліки у власному коді, обрати відповідні методи рефакторингу та застосувати їх на реальних прикладах. У цьому звіті продемонстровано використання трьох методів рефакторингу з книги Мартіна Фаулера, що дозволили підвищити читабельність, гнучкість та підтримуваність коду.
Для виконання практичного завдання було обрано три методи рефакторингу відповідно до класифікації Мартіна Фаулера:
1.	Hide Delegate (Приховування делегата)
2.	Pull Up Method (Підняття методу)
3.	Replace Parameter with Explicit Methods (Заміна параметра явними методами)
Ці методи були вибрані відповідно до реальних проблем, що виникли у фрагментах коду з моїх навчальних та проєктних робіт, і демонструють різні аспекти покращення структури програмного забезпечення.

3.2 Метод «Hide Delegate»
3.2.1 Опис проблеми
У вихідному коді бекенда DeBillPay багато ендпоїнтів напряму працювали з клеймами користувача в HttpContext. Наприклад, для отримання ідентифікатора користувача в кожному методі повторювався один і той самий фрагмент: звернення до http.User, пошук клейма ClaimTypes.NameIdentifier, отримання рядкового значення та його перетворення в int. Такий підхід призводив до дублювання коду й сильної залежності кожного ендпоїнта від деталей реалізації аутентифікації. Будь-яка зміна у способі зберігання ідентифікатора користувача вимагала б редагування великої кількості місць у коді, що робить систему крихкою та важчою в обслуговуванні.
3.2.2 Код до рефакторингу
1 app.MapGet("/api/contacts", async (HttpContext http, ApplicationDbContext db) 2 =>
3 {
4     var userIdClaim = http.User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
5     if (userIdClaim == null)
6         return Results.Unauthorized();
7 
8     int userId = int.Parse(userIdClaim);
9 
10    var contacts = await db.Contacts
11        .Where(c => c.UserId == userId)
12        .Include(c => c.Friend)
13        .Select(c => new
14        {
15            c.ContactId,
16            c.Status,
17            Friend = new
18            {
19                c.Friend.UserId,
20                c.Friend.FirstName,
21                c.Friend.LastName,
22                c.Friend.Email,
23                c.Friend.PhoneNumber
24            }
25        })
26        .ToListAsync();
27
28    return Results.Ok(contacts);
29 })
30 .RequireAuthorization();
3.2.3 Суть методу
Метод Hide Delegate застосовується тоді, коли клієнтський код занадто багато знає про внутрішню структуру інших об’єктів або викликає занадто довгі ланцюжки звернень. Ідея полягає в тому, щоб приховати такі деталі за спеціальним методом чи властивістю і надати клієнту простий, зрозумілий інтерфейс. Клас, який раніше «делегував» виклики далі по ланцюжку, бере це делегування на себе. У результаті клієнт працює лише з одним об’єктом і не залежить від внутрішньої організації інших складових системи. Це зменшує зв’язаність і полегшує внесення змін у майбутньому.
3.2.4 Код після рефакторингу
Спочатку було додано розширення для HttpContext, яке інкапсулює логіку отримання ідентифікатора користувача:
1 public static class HttpContextExtensions
2 {
3     public static int? GetUserId(this HttpContext http)
4     {
5         var claim = http.User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
6         if (claim is null)
7             return null;
8 
9         return int.Parse(claim);
10     }
11 }
Після цього ендпоїнт було спрощено:
1 app.MapGet("/api/contacts", async (HttpContext http, ApplicationDbContext db) 2 =>
3 {
4     var userId = http.GetUserId();
5    if (userId is null)
6        return Results.Unauthorized();
7
8    var contacts = await db.Contacts
9        .Where(c => c.UserId == userId.Value)
10        .Include(c => c.Friend)
11        .Select(c => new
12        {
13            c.ContactId,
14            c.Status,
15            Friend = new
16            {
17                c.Friend.UserId,
18                c.Friend.FirstName,
19                c.Friend.LastName,
20                c.Friend.Email,
21                c.Friend.PhoneNumber
22            }
23        })
24        .ToListAsync();
25
26    return Results.Ok(contacts);
27 })
28 .RequireAuthorization();

3.2.5 Переваги після рефакторингу
Після застосування методу Hide Delegate код став менш залежним від деталей реалізації механізму аутентифікації. Уся логіка роботи з клеймами користувача зосереджена в одному місці в методі-розширенні GetUserId. Це значно спрощує підтримку: у разі зміни формату клейм або способу збереження ідентифікатора достатньо оновити лише одну функцію. Ендпоїнти стали компактнішими, читабельнішими і містять тільки ту логіку, яка безпосередньо стосується обробки запиту. Такий підхід знижує зв’язаність між компонентами системи, покращує розширюваність та робить програмний код більш стійким до змін.
3.3 Метод «Pull Up Method»
3.3.1 Опис проблеми
У класах Master та TraineeMaster з’явився однаковий метод для обчислення стажу або категорії працівника. Дублювання коду створювало зайву складність: якщо змінювали логіку визначення рівня майстерності, це потрібно було робити у двох місцях. Така структура підвищувала ризик помилок і порушувала принцип DRY. Виникла потреба винести спільну логіку в базовий клас.

3.3.2 Код до рефакторингу
1 public class Master : Employee
2 {
3     public string GetExperienceLevel()
4    {
5         return YearsOfExperience > 5 ? "Senior" : "Regular";
6     }
7 }
8
9 public class TraineeMaster : Employee
10 {
11     public string GetExperienceLevel()
12     {
13         return YearsOfExperience > 5 ? "Senior" : "Regular";
14     }
15 }
3.3.3 Суть методу
Pull Up Method використовується для усунення дублювання, коли кілька підкласів містять однакові методи. Суть методу полягає у перенесенні спільної логіки до базового класу, щоб всі підкласи могли її успадковувати. Це дозволяє централізувати поведінку, яку розділяють нащадки, уникнути копіювання коду та зменшити ризик помилок під час внесення змін. У результаті структура класів стає чистішою та простішою у підтримці.
3.3.4 Код після рефакторингу
1 public abstract class Employee
2 {
3    public int YearsOfExperience { get; set; }
4
5     public string GetExperienceLevel()
6     {
7         return YearsOfExperience > 5 ? "Senior" : "Regular";
8     }
9 }
10 
11 public class Master : Employee { }
12
13 public class TraineeMaster : Employee { }
3.3.5 Переваги після рефакторингу
Після рефакторингу код став значно чистішим, оскільки дублювання методу повністю усунено. Тепер логіка визначення рівня працівника зосереджена в одному місці - у базовому класі, що гарантує єдину поведінку для всіх підкласів. Підтримка такого коду стала набагато простішою, а ймовірність помилок під час зміни логіки - значно меншою. Ієрархія класів стала більш узгодженою, а сама модель - структурованішою та зрозумілішою.

3.4 Метод «Replace Parameter with Explicit Methods»
3.4.1 Опис проблеми
У функціоналі роботи з електронними рахунками (e-bill) в бекенді DeBillPay логіка розподілу суми боргу між учасниками залежала від сценарію, що зберігався у полі Scenario об’єкта Ebill. В окремому допоміжному методі використовувався параметр scenario, і всередині нього за допомогою кількох умов (if / else if) визначалося, як саме слід обробляти дані для різних сценаріїв: «рівний розподіл», «спільні витрати» або «індивідуальні суми». Такий підхід ускладнював читання коду, збільшував кількість умовної логіки та ускладнював додавання нових сценаріїв, оскільки кожна зміна вимагала редагування одного «великий» методу з параметром.
3.4.2 Код до рефакторингу
1 private void RecalculateAssignments(Ebill ebill, string scenario)
2 {
3     scenario = scenario.ToLower();
4 
5     if (scenario == "рівний розподіл" || scenario == "спільні витрати")
6     {
7         decimal equal = Math.Round(ebill.AmountOfDept / ebill.Participants.Count);
8 
9         foreach (var p in ebill.Participants)
10        {
11            p.AssignedAmount = equal;
12
13           if (scenario == "спільні витрати")
14                p.Balance = p.PaidAmount;
15        }
16    }
17    else if (scenario == "індивідуальні суми")
18    {
19        decimal sumAssigned = ebill.Participants.Sum(p => p.AssignedAmount);
20        if (sumAssigned > ebill.AmountOfDept)
21        {
22            decimal diff = sumAssigned - ebill.AmountOfDept;
23            var lastPart = ebill.Participants.LastOrDefault();
24            if (lastPart != null)
25                lastPart.AssignedAmount = Math.Max(0, lastPart.AssignedAmount - diff);
26        }
27    }
28
29    foreach (var p in ebill.Participants)
30    {
31        if (p.Balance >= p.AssignedAmount) p.PaymentStatus = "погашений";
32        else if (p.Balance == 0) p.PaymentStatus = "непогашений";
33        else p.PaymentStatus = "частково погашений";
34    }
35 }
3.4.3 Суть методу
Метод Replace Parameter with Explicit Methods передбачає заміну одного методу з параметром, який визначає режим роботи, на кілька окремих методів із чіткими назвами. Замість того щоб мати одну функцію з великою кількістю умов всередині, кожен сценарій отримує власний метод без параметра, що відображає конкретну дію. Завдяки цьому інтерфейс класу стає самодокументованим, а умовна логіка простішою або взагалі перенесеною на рівень вибору відповідного методу. Такий підхід зменшує складність, підвищує ясність коду та полегшує подальше розширення функціоналу.

3.4.4 Код після рефакторингу
Після рефакторингу логіку для різних сценаріїв було винесено у окремі методи:
1 private void ApplyEqualSplitScenario(Ebill ebill)
2 {
3     decimal equal = Math.Round(ebill.AmountOfDept / ebill.Participants.Count);
4 
5     foreach (var p in ebill.Participants)
6     {
7         p.AssignedAmount = equal;
8     }
9 
10    UpdatePaymentStatuses(ebill);
11}
12
13private void ApplySharedExpensesScenario(Ebill ebill)
14{
15    decimal equal = Math.Round(ebill.AmountOfDept / ebill.Participants.Count);
16
17    foreach (var p in ebill.Participants)
18    {
19        p.AssignedAmount = equal;
20        p.Balance = p.PaidAmount;
21    }
22
23    UpdatePaymentStatuses(ebill);
24}
25
26 private void ApplyIndividualAmountsScenario(Ebill ebill)
27{
28    decimal sumAssigned = ebill.Participants.Sum(p => p.AssignedAmount);
29    if (sumAssigned > ebill.AmountOfDept)
30    {
31        decimal diff = sumAssigned - ebill.AmountOfDept;
32        var lastPart = ebill.Participants.LastOrDefault();
33        if (lastPart != null)
34            lastPart.AssignedAmount = Math.Max(0, lastPart.AssignedAmount - 35diff);
36    }
37
38    UpdatePaymentStatuses(ebill);
39}
40
41private void UpdatePaymentStatuses(Ebill ebill)
42{
43    foreach (var p in ebill.Participants)
44    {
45        if (p.Balance >= p.AssignedAmount) p.PaymentStatus = "погашений";
46        else if (p.Balance == 0) p.PaymentStatus = "непогашений";
47        else p.PaymentStatus = "частково погашений";
48    }
49}
3.4.5 Переваги після рефакторингу
Після застосування методу Replace Parameter with Explicit Methods код став набагато зрозумілішим і структурованішим. Кожен сценарій має власний метод з чіткою назвою, що дозволяє одразу зрозуміти його призначення без аналізу умовної логіки. Це спрощує тестування, оскільки кожен випадок можна перевіряти окремо, а також полегшує додавання нових сценаріїв у майбутньому. Винесення спільної частини в окремий метод UpdatePaymentStatuses усуває дублювання та ще більше підвищує читабельність. У результаті зменшилася кількість умовних операторів, знизилась складність коду та покращилася його підтримуваність.
3.5 Інструменти рефакторингу у Visual Studio
Visual Studio містить великий набір вбудованих інструментів, що дозволяють розробникам виконувати рефакторинг коду швидко, безпечно та з автоматичним оновленням усіх залежностей. Основні функції доступні через меню Quick Actions and Refactorings (Ctrl + .) або через контекстне меню редактора коду.
Одним із найпоширеніших інструментів є Rename, який дозволяє змінювати назви класів, методів, полів, властивостей та інших елементів, автоматично оновлюючи всі посилання в проєкті. Інструмент Extract Method використовується для виділення частини коду в окремий метод, що допомагає спростити довгі або складні функції. Аналогічно, можливість Extract Interface дає змогу автоматично створити інтерфейс на основі вибраного класу.
Корисним засобом є також Move to File / Move Type to File, який переносить клас або інший тип у новий файл, підтримуючи належну структуру проєкту. За допомогою інструменту Encapsulate Field можна швидко створити властивість для приватного поля та замінити прямі звернення до нього у всьому коді. Окрім цього, Visual Studio надає стандартні функції, такі як Remove and Sort Usings, Simplify Name, Inline Temporary Variable, Introduce Variable, що сприяють підвищенню читабельності та оптимізації структури коду.
Завдяки цим інструментам розробник отримує можливість проводити рефакторинг системно та безпечно, не витрачаючи час на ручне пошукання та оновлення залежностей. Visual Studio виконує більшість рутини автоматично, що помітно підвищує якість програмного коду та пришвидшує роботу над проєктами будь-якого масштабу.
 
4 ВИСНОВКИ
У процесі виконання практичного завдання було досліджено та застосовано декілька методів рефакторингу коду з книги Мартіна Фаулера. Вибрані техніки  Hide Delegate, Pull Up Method та Replace Parameter with Explicit Methods дали змогу проаналізувати типові проблеми в реальному програмному коді та продемонструвати способи оптимізації структури програмного забезпечення без зміни його зовнішньої поведінки. Застосування цих методів допомогло зменшити зв’язаність між компонентами, усунути дублювання логіки, підвищити читабельність структури класів, спростити підтримку та зробити програмний код більш узгодженим і гнучким.
Рефакторинг показав, що навіть невеликі локальні зміни можуть суттєво покращити якість системи та її архітектуру. Використання інструментів Visual Studio дало змогу виконувати трансформації коду швидко й безпечно, мінімізуючи ризик помилок. Отримані результати підтверджують важливість систематичного підходу до рефакторингу та демонструють його значення в професійній розробці програмного забезпечення.
 
5 ВИКОРИСТАНІ ДЖЕРЕЛА
1.	Fowler M. Refactoring: Improving the Design of Existing Code. URL: https://martinfowler.com/books/refactoring.html (дата звернення: 28.11.2025).
2.	Hide Delegate. Refactoring and Design Patterns. URL: https://refactoring.guru/hide-delegate (дата звернення: 28.11.2025).
3.	Pull Up Method. Refactoring and Design Patterns. URL: https://refactoring.guru/pull-up-method (дата звернення: 28.11.2025).
4.	Replace Parameter with Explicit Methods. Refactoring and Design Patterns. URL: https://refactoring.guru/replace-parameter-with-explicit-methods (дата звернення: 28.11.2025).
5.	Refactoring in Visual Studio. Microsoft Learn. URL: https://learn.microsoft.com/en-us/visualstudio/ide/refactoring (дата звернення: 28.11.2025).
 
ДОДАТОК А
	YouTube: https://youtu.be/c5lg6N5cDR0

00:00 - 00:09 – Титульний слайд
 
00:09 - 00:30 – Вступ
 
00:30 - 00:55 – Використані методи та проєкти
 
00:55 - 01:36 – Метод 1: Hide Delegate (Проблема)
 
01:36 - 02:13 – Метод 1: Hide Delegate (Рішення та переваги)
 
02:13 - 02:50 – Метод 2: Pull Up Method (Проблема)
 
02:50 - 03:25 – Метод 2: Pull Up Method (Рішення та переваги)
 
03:25 - 04:07 – Метод 3: Replace Parameter with Explicit Methods (Проблема)
 
04:07 - 04:30 – Метод 3: Replace Parameter with Explicit Methods (Рішення та переваги)
 
04:30 - 05:15 – Інструменти рефакторингу у Visual Studio
 
05:15 - 05:55 – Інструменти рефакторингу у Visual Studio
 
05:55 - 06:32 – Висновок 
ДОДАТОК Б
Слайди презентації
 
Рисунок Б.1 – Титульний слайд
 
Рисунок Б.2 – Вступ
 
Рисунок Б.3 – Використані методи та проєкти
 
Рисунок Б.4 – Метод 1: Hide Delegate (Проблема)
 
Рисунок Б.5 – Метод 1: Hide Delegate (Рішення та переваги)
 
Рисунок Б.6 – Метод 2: Pull Up Method (Проблема)
 
Рисунок Б.7 – Метод 2: Pull Up Method (Рішення та переваги)
 
Рисунок Б.8 – Метод 3: Replace Parameter with Explicit Methods (Проблема)
 
Рисунок Б.9 – Метод 3: Replace Parameter with Explicit Methods (Рішення та переваги)
 
Рисунок Б.10 – Інструменти рефакторингу у Visual Studio
 
Рисунок Б.11 – Інструменти рефакторингу у Visual Studio
 
Рисунок Б.12 – Висновок

 
ДОДАТОК В
GitHub DeBillPay : https://github.com/Team-DeBillPay/DeBillPay_Backend
GitHub AutoRepair: https://github.com/NureMykhailenkoDenys/autorepaircw

