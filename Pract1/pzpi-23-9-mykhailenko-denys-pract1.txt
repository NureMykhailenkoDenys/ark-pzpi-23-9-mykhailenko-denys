Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії





Звіт
до практичного завдання №1
з дисципліни «Аналіз та рефакторинг коду»
на тему: «Основні рекомендації написання коду мовою програмування Rust»






Виконав:
ст. гр. ПЗПІ-23-9
Михайленко Денис Олегович
	                     Перевірив:
                     ст. викладач кафедри ПІ
                     Сокорчук Ігор Петрович	







Харків 2025
1 ІСТОРІЯ ЗМІН
№	Дата	Версія звіту	Опис змін та виправлень
1	30.10.2025	0.1	Початкова версія документу
2	31.10.2025	1	Остаточна версія документ 




































2 ЗАВДАННЯ
Студент повинен обрати мову програмування, дослідити основні рекомендації для написання якісного коду у цій мові, продемонструвати ці рекомендації на прикладах коду, обґрунтувати кожну рекомендацію і надати детальні пояснення. Для кожного прикладу мають бути наведені фрагменти коду.
 
3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Вступ    
Мова програмування Rust - це сучасна системна мова, розроблена компанією Mozilla для створення швидких, безпечних і надійних програм. Вона поєднує ефективність мов низького рівня, таких як C і C++, з безпекою високорівневих мов, завдяки суворій системі типів і механізму володіння пам’яттю. Rust забезпечує високу продуктивність, відсутність витоків пам’яті й захист від конкурентних помилок. Його філософія ґрунтується на принципі: «Безпека без втрати швидкодії». Саме тому мову Rust активно застосовують для розробки операційних систем, вебсерверів, ігор, драйверів та високонавантажених сервісів.
Дотримання правил написання чистого, зрозумілого й безпечного коду є ключовою частиною ефективного програмування на Rust. У цій роботі розглянуто основні рекомендації щодо стилю, структуризації, тестування й рефакторингу коду, які сприяють підвищенню якості програмного забезпечення та полегшують його подальшу підтримку.
3.2 Основні рекомендації написання коду мовою Rust
3.2.1 Рекомендація 1: Використовуйте осмислені назви змінних, функцій та структур
Опис : 
Iменування у Rust має бути зрозумілим і відповідати конвенціям мови: функції, змінні та поля структур записуються у snake_case, а типи, структури й переліки (enum) у PascalCase.
Приклад:
1 // Поганий приклад
2 fn F(x: i32) -> i32 { x * 2 }
3 
4 // Гарний приклад
5 fn multiply_by_two(number: i32) -> i32 {
6     number * 2
7 }
Пояснення:
Такі правила встановлені у Rust API Guidelines. Вони роблять код зрозумілим і передбачуваним. Непослідовне іменування ускладнює читання й командну роботу над проєктом.
3.2.2 Рекомендація 2: Уникайте використання unwrap() без обробки помилок
Опис:
Метод unwrap() викликає аварійне завершення програми, якщо операція завершується з помилкою. Безпечніше обробляти помилки через match або оператор ?.
Приклад:
1	// Поганий приклад
2 let text = std::fs::read_to_string("config.txt").unwrap();
3 
4 // Гарний приклад
5 let text = std::fs::read_to_string("config.txt")
6     .unwrap_or_else(|_| "Файл не знайдено".to_string());
Пояснення:
Rust не має винятків, тому неправильне використання unwrap() суперечить філософії безпеки мови. Обробка помилок через Result запобігає раптовим збоям і робить програму надійнішою.
3.2.3 Рекомендація 3: Використовуйте Option та Result для безпечної обробки даних
Опис:
У Rust немає null. Замість нього використовуються типи Option<T> і Result<T, E>, які вимагають явного врахування всіх можливих результатів виконання.
Приклад:
1	// Поганий приклад
2 fn divide(a: f64, b: f64) -> f64 {
3     a / b // можливий поділ на нуль
4 }
5 
6 // Гарний приклад
7 fn divide(a: f64, b: f64) -> Option<f64> {
8     if b == 0.0 { None } else { Some(a / b) }
9 }
Пояснення:
Це допомагає уникнути типових помилок, подібних до Null Pointer Exception у Java чи C#. Завдяки суворій типізації Rust змушує програміста писати передбачуваний і безпечний код.
3.2.4 Рекомендація 4: Документуйте код за допомогою коментарів ///
Опис:
Rust має вбудовану систему документації, яка генерує HTML документи з коментарів типу ///. Документування це частина стандарту якості коду.
Приклад:
1 // Поганий приклад
2 fn factorial(n: i32) -> i32 { (1..=n).product() }
3 
4 // Гарний приклад
5 /// Обчислює факторіал числа.
6 /// Повертає None, якщо число є від’ємним.
7 fn factorial(n: i32) -> Option<u64> {
8     if n < 0 { None } else { Some((1..=n as u64).product()) }
9 }
Пояснення:
Коментарі /// можна автоматично перетворити на документацію за допомогою команди cargo doc. Це покращує підтримку коду, особливо в командних проєктах.
3.2.5 Рекомендація 5: Використовуйте cargo fmt для автоматичного форматування коду
Опис:
cargo fmt - це офіційний інструмент форматування, який забезпечує єдиний стиль оформлення коду у всьому проєкті.
Приклад:
1 // Поганий приклад
2 fn   sum (a:i32,b:i32)->i32{a+b}
3 
4 // Гарний приклад
5 fn sum(a: i32, b: i32) -> i32 {
6     a + b
7 }
Пояснення:
Форматування підвищує читабельність і полегшує перевірку коду. Команда cargo fmt гарантує однаковий стиль незалежно від розробника чи IDE.

3.2.6 Рекомендація 6: Розділяйте код на модулі
Опис:
Великі програми потрібно структурувати у вигляді модулів, що підвищує зрозумілість і дозволяє розділити логіку.
Приклад:
1 // Поганий приклад
2 fn main() {
3     let s = 5;
4     println!("{}", s * s);
5 }
6 
7 // Гарний приклад
8 mod math {
9     pub fn square(x: i32) -> i32 { x * x }
10}
11 
12 fn main() {
13     println!("{}", math::square(5));
14 }
Пояснення:
Модульна структура це основа підтримуваного коду. Rust дозволяє створювати вкладені модулі, що зручно для великих застосунків і бібліотек.
3.2.7 Рекомендація 7: Пишіть модульні тести
Опис:
Тести в Rust інтегровані в систему cargo. Вони допомагають перевіряти правильність роботи функцій та класів.
Приклад:
1 // Поганий приклад
2 fn multiply(a: i32, b: i32) -> i32 { a * b }
3 
4 // Гарний приклад
5 #[cfg(test)]
6 mod tests {
7     use super::*;
8     #[test]
9     fn test_multiply() {
10        assert_eq!(multiply(2, 3), 6);
11    }
12}
Пояснення:
Модульні тести підвищують якість коду й запобігають появі регресій після рефакторингу. 
3.2.8 Рекомендація 8: Уникайте дублювання коду (принцип DRY)
Опис:
Не повторюйте однакову логіку в кількох місцях. Виділяйте спільні операції у функції чи модулі.
Приклад:
1 // Поганий приклад
2 let area1 = 5.0 * 10.0;
3 let area2 = 3.0 * 6.0;
4 
5 // Гарний приклад
6 fn calculate_area(w: f64, h: f64) -> f64 { w * h }
7 let area1 = calculate_area(5.0, 10.0);
8 let area2 = calculate_area(3.0, 6.0);
Пояснення:
Дотримання принципу Don’t Repeat Yourself (DRY) робить код більш підтримуваним і зменшує ризик логічних помилок при змінах.
3.2.9 Рекомендація 9: Використовуйте borrow checker для безпечної роботи з пам’яттю
Опис:
Borrow checker - це механізм Rust, який контролює володіння й запозичення даних, запобігаючи помилкам керування пам’яттю.
Приклад:
1 // Поганий приклад (якби Rust це дозволив)
2 fn main() {
3     let name = String::from("Denys");
4     let ref1 = &mut name;
5     let ref2 = &name; // неможливо — порушення borrow checker
6 }
7 
8 // Гарний приклад
9 fn print_name(name: &String) {
10     println!("Hello, {}", name);
11 }
12 
13 fn main() {
14     let user = String::from("Denys");
15     print_name(&user);
16 }
Пояснення:
Borrow checker унеможливлює одночасне змінне та незмінне запозичення змінних. Це основа безпеки пам’яті без потреби у збирачі сміття.
3.2.10 Рекомендація 10: Використовуйте cargo clippy для автоматичного аналізу коду
Опис:
cargo clippy - це статичний аналізатор, який перевіряє код і пропонує покращення.
Приклад:
1 // Поганий приклад
2 if x == true { do_something(); }
3 
4 // Гарний приклад
5 if x { do_something(); }
Пояснення:
Clippy виявляє неефективні або некоректні конструкції й підказує, як зробити код чистішим. Регулярне використання цього інструмента підтримує високі стандарти якості у проєкті.
 
4 ВИСНОВКИ
У процесі вивчення рекомендацій щодо написання якісного коду мовою програмування Rust було проаналізовано основні принципи, які впливають на читабельність, підтримуваність і безпеку програмного забезпечення.
Мова Rust відзначається строгими правилами типізації, відсутністю null, використанням Option та Result для обробки помилок, а також потужною системою контролю володіння пам’яттю borrow checker. Ці особливості формують унікальні вимоги до стилю програмування, які обов’язково слід враховувати при розробці.
Розглянуті рекомендації, зокрема правильне іменування, модульність, тестування, уникнення unwrap(), використання інструментів cargo fmt та clippy, допомагають не лише покращити якість коду, але й зробити його більш стабільним, масштабованим і зрозумілим для інших розробників. Таким чином, дотримання принципів написання чистого коду в Rust - це не лише ознака професійності програміста, а й важлива складова побудови надійних і безпечних програмних систем.
 
5 ВИКОРИСТАНІ ДЖЕРЕЛА
1.	Klabnik S., Nichols C. The Rust Programming Language [Електронний ресурс]. – Режим доступу: https://doc.rust-lang.org/book/ (дата звернення: 31.10.2025).
2.	Rust Style Guide [Електронний ресурс]. – Режим доступу: https://doc.rust-lang.org/nightly/style-guide (дата звернення: 31.10.2025).
3.	Fowler M. Refactoring: Improving the Design of Existing Code. – 2nd ed. – Boston: Addison-Wesley, 2019. – 448 p.
4.	Rust API Guidelines [Електронний ресурс]. – Режим доступу: https://rust-lang.github.io/api-guidelines/ (дата звернення: 31.10.2025).
5.	Cargo Clippy Linter Documentation [Електронний ресурс]. – Режим доступу: https://github.com/rust-lang/rust-clippy (дата звернення: 31.10.2025).
6.	Mozilla Foundation. Why Rust? [Електронний ресурс]. – Режим доступу: https://www.rust-lang.org/what/why (дата звернення: 31.10.2025).
 
ДОДАТОК А
Посилання на відео - https://youtu.be/uNG77zNV9m8
00:00 Початок
00:12 Вступ
00:51 Рекомендація 1 - Використовуйте осмислені назви змінних, функцій і структур.
01:19 Рекомендація 2 - Уникайте використання методу unwrap() без обробки помилок.
01:50 Рекомендація 3 - Використовуйте Option і Result для безпечної обробки даних.
02:16 Рекомендація 4 - Документуйте код за допомогою коментарів ///
02:45 Рекомендація 5 - Використовуйте cargo fmt для автоматичного форматування коду.
03:13 Рекомендація 6 - Розділяйте код на модулі.
03:40 Рекомендація 7 - Пишіть модульні тести.
04:05 Рекомендація 8 - Уникайте дублювання коду, дотримуйтеся принципу DRY.
04:33 Рекомендація 9 - Використовуйте borrow checker для безпечної роботи з пам’яттю.
05:05 Рекомендація 10 - Використовуйте cargo clippy для аналізу коду.
05:29 Висновок
 
ДОДАТОК Б
Слайди презентації
 
Рисунок Б.1 — Титульна сторінка
 
Рисунок Б.2 — Вступ
 
Рисунок Б.3 — Рекомендація 1
 
Рисунок Б.4 — Рекомендація 2
 
Рисунок Б.5 — Рекомендація 3
 
Рисунок Б.6 — Рекомендація 4
 
Рисунок Б.7 — Рекомендація 5
 
Рисунок Б.8 — Рекомендація 6
 
Рисунок Б.9 — Рекомендація 7
 
Рисунок Б.10 — Рекомендація 8
 
Рисунок Б.11 — Рекомендація 9
 
Рисунок Б.12 — Рекомендація 10
 
Рисунок Б.13 — Висновок
 
ДОДАТОК С
Програмний код - https://github.com/NureMykhailenkoDenys/ark-pzpi-23-9-mykhailenko-denys/blob/main/Pract1/pzpi-23-9-mykhailenko-denys-pract1/code-examples-code-conventions.rs
